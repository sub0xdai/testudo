//! OODA types - Core public types for the trading loop

use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use std::time::{Duration, Instant};
use testudo_types::OrderSide;

// --- Core OODA Loop Data Structures ---

/// User's intent to trade, including risk parameters.
#[derive(Debug, Clone)]
pub struct TradeIntent {
    pub symbol: String,
    pub direction: TradeDirection,
    pub account_equity: Decimal,
    pub risk_percentage: Decimal,
}

/// A snapshot of market conditions for a specific symbol.
#[derive(Debug, Clone)]
pub struct MarketObservation {
    pub symbol: String,
    pub price: f64,
    pub volume: f64,
    pub timestamp: Instant,
}

/// A fully calculated trade setup, including position size.
/// This is the output of the Orient phase.
#[derive(Debug, Clone)]
pub struct TradeSetup {
    pub symbol: String,
    pub entry_price: Decimal,
    pub stop_loss: Decimal,
    pub take_profit: Option<Decimal>,
    pub position_size: Decimal,
    pub side: OrderSide,
}

/// A proposal generated by the Orientator, ready for risk assessment.
#[derive(Debug, Clone)]
pub struct TradeProposal {
    pub symbol: String,
    pub side: OrderSide,
    pub entry_price: Decimal,
    pub stop_loss: Decimal,
    pub take_profit: Option<Decimal>,
    pub position_size: Decimal,
}

/// The final, approved plan ready for execution by the Act phase.
#[derive(Debug, Clone)]
pub struct ExecutionPlan {
    pub setup: TradeSetup,
    pub approved: bool,
    pub risk_assessment: String,
}

// --- Enums and Metrics ---

/// The direction of a trade.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TradeDirection {
    Long,
    Short,
}

/// The current phase of the OODA loop.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum OodaPhase {
    Observe,
    Orient,
    Decide,
    Act,
}

/// Performance metrics for monitoring the OODA loop's latency.
#[derive(Debug, Clone)]
pub struct LoopMetrics {
    pub observe_latency: Option<Duration>,
    pub orient_latency: Option<Duration>,
    pub decide_latency: Option<Duration>,
    pub act_duration: Duration,
    pub total_latency: Option<Duration>,
    pub last_updated: Instant,
    pub last_execution_time: Option<DateTime<Utc>>,
}

impl LoopMetrics {
    pub fn new() -> Self {
        Self {
            observe_latency: None,
            orient_latency: None,
            decide_latency: None,
            act_duration: Duration::default(),
            total_latency: None,
            last_updated: Instant::now(),
            last_execution_time: None,
        }
    }
}

impl Default for LoopMetrics {
    fn default() -> Self {
        Self::new()
    }
}

/// Error types for the decision process.
#[derive(Debug, Clone, thiserror::Error)]
pub enum DecisionError {
    #[error("Risk protocol error: {0}")]
    ProtocolError(String),
    #[error("Decision timeout: {0}")]
    AssessmentTimeout(String),
    #[error("Invalid proposal: {0}")]
    InvalidProposal(String),
    #[error("Decision system error: {0}")]
    SystemError(String),
    #[error("Type conversion error: {0}")]
    ConversionError(String),
}

impl From<disciplina::PositionSizingError> for DecisionError {
    fn from(err: disciplina::PositionSizingError) -> Self {
        DecisionError::ConversionError(err.to_string())
    }
}
